/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.2.4.0 (NJsonSchema v9.13.36.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import 'rxjs/add/observable/fromPromise';
import 'rxjs/add/observable/of';
import 'rxjs/add/observable/throw';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/toPromise';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/catch';

import { Observable } from 'rxjs/Observable';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IInventoryClient {
    /**
     * @return Success
     */
    getReportList(): Observable<Report[]>;
    /**
     * @return Success
     */
    generateTechMatReport(): Observable<void>;
    /**
     * @return Success
     */
    downloadReport(reportId: string): Observable<void>;
    /**
     * @return Success
     */
    deleteReportById(reportId: string): Observable<void>;
    /**
     * Lists all companies
     * @return Success
     */
    getCompanies(): Observable<Company[]>;
    /**
     * Updates a company and if there are removed locations their stock + damaged material gets added to the default
    location.
     * @param updated (optional) 
     * @return Success
     */
    updateCompany(updated: Company | null | undefined): Observable<void>;
    /**
     * Create a new company
     * @param company (optional) 
     * @return Success
     */
    newCompany(company: Company | null | undefined): Observable<void>;
    /**
     * Returns a company by id
     * @return Success
     */
    getCompanyById(id: string): Observable<Company>;
    /**
     * Delete company by id
     * @return Success
     */
    deleteCompanyById(id: string): Observable<void>;
    /**
     * Generate a grade and material,servants distribution list template for the given company
    1) If the company has only the default location it generates only KP Rw (initial report).
    2) If there are additional locations it generates a distribution excel =&gt; to distribute all material,servants to
    the
    locations.
     * @return Success
     */
    downloadCompanyTemplate(companyName: string): Observable<FileContentResult>;
    /**
     * Initialize the inventory per company and distribute the company's stock to it's locations (typically at the begging
    of a "WK" or after a "Micro Dispo")
     * @param initialReportPerCompany (optional) filled template file (empty cells = 0)
     * @return Success
     */
    apiCompaniesByCompanyNameReportPost(companyName: string, initialReportPerCompany: any | null | undefined): Observable<void>;
    /**
     * Get the inventory for one company
     * @return Success
     */
    getMaterialInventory(company: string): Observable<MaterialInventoryItem[]>;
    /**
     * Get the inventory for all companies
     * @return Success
     */
    getMaterialInventoryForAll(): Observable<MaterialInventoryItem[]>;
    /**
     * @return Success
     */
    getMaterialInventoryForLocation(company: string, location: string, sapNr: string): Observable<MaterialAllocation>;
    /**
     * (currently not in use)  Distribute the company stock to it's locations (typically done after a "Micro Dispo".
     * @param distributionList (optional) 
     * @return Success
     */
    distributeMaterialForCompany(companyName: string, sapNr: string, distributionList: MaterialDistribution | null | undefined): Observable<void>;
    /**
     * Report that a certain material got damaged (typically only used during exercises)
     * @param patch (optional) 
     * @return Success
     */
    materialDefect(company: string, location: string, sapNr: string, patch: PatchAmount | null | undefined): Observable<void>;
    /**
     * Report a damaged material got repaired (typically only used during exercises)
     * @param patch (optional) 
     * @return Success
     */
    materialRepaired(company: string, location: string, sapNr: string, patch: PatchAmount | null | undefined): Observable<void>;
    /**
     * You can change (+/-) the material in use on a location.
     * @param company Company identifier
     * @param sapNr Material used
     * @param location Location of the company
     * @param patch (optional) Change
     * @return Success
     */
    materialUsed(company: string, sapNr: string, location: string, patch: PatchAmount | null | undefined): Observable<void>;
    /**
     * Corrects the stock.
     * @param newStock (optional) 
     * @return Success
     */
    correctMaterialStock(company: string, sapNr: string, location: string, newStock: PatchAmount | null | undefined): Observable<void>;
    /**
     * Returns all defined material.
     * @return Success
     */
    getMaterialList(): Observable<Material[]>;
    /**
     * Creates a new material
     * @param material (optional) 
     * @return Success
     */
    newMaterial(material: Material | null | undefined): Observable<void>;
    /**
     * Returns a material by its number (unique).
     * @return Success
     */
    getMaterialById(id: string): Observable<Material>;
    /**
     * Updates an existing material
     * @param material (optional) 
     * @return Success
     */
    updateMaterial(id: string, material: Material | null | undefined): Observable<void>;
    /**
     * Delete material by id
     * @return Success
     */
    deleteMaterialById(id: string): Observable<void>;
    /**
     * Get the servant inventory for one company
     * @return Success
     */
    getServantInventory(company: string): Observable<ServantInventoryItem[]>;
    /**
     * Get the servant inventory for all companies
     * @return Success
     */
    getServantInventoryForAll(): Observable<ServantInventoryItem[]>;
    /**
     * @return Success
     */
    getServantInventoryForLocation(company: string, location: string, grade: Grade): Observable<ServantAllocation>;
    /**
     * (currently not in use)  Distribute the company stock to it's locations (typically done after a "Micro Dispo".
     * @param distributionList (optional) 
     * @return Success
     */
    distributeServantsForCompany(companyName: string, grade: Grade2, distributionList: GradeDistribution | null | undefined): Observable<void>;
    /**
     * Report that a certain material got damaged (typically only used during exercises)
     * @param patch (optional) 
     * @return Success
     */
    servantDetached(company: string, location: string, grade: Grade3, patch: PatchAmount | null | undefined): Observable<void>;
    /**
     * Report a damaged material got repaired (typically only used during exercises)
     * @param patch (optional) 
     * @return Success
     */
    servantReturned(company: string, location: string, grade: Grade4, patch: PatchAmount | null | undefined): Observable<void>;
    /**
     * You can change (+/-) the material in use on a location.
     * @param company Company identifier
     * @param grade Material used
     * @param location Location of the company
     * @param patch (optional) Change
     * @return Success
     */
    servantUsed(company: string, grade: Grade5, location: string, patch: PatchAmount | null | undefined): Observable<void>;
    /**
     * Corrects the stock.
     * @param newStock (optional) 
     * @return Success
     */
    correctServantStock(company: string, grade: Grade6, location: string, newStock: PatchAmount | null | undefined): Observable<void>;
    /**
     * Corrects the ideal for company.
     * @param newIdeal (optional) 
     * @return Success
     */
    correctIdealForCompany(company: string, grade: Grade7, newIdeal: PatchAmount | null | undefined): Observable<void>;
}

@Injectable()
export class InventoryClient implements IInventoryClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getReportList(): Observable<Report[]> {
        let url_ = this.baseUrl + "/api/Bataillon/reports/material";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetReportList(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReportList(<any>response_);
                } catch (e) {
                    return <Observable<Report[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Report[]>><any>Observable.throw(response_);
        });
    }

    protected processGetReportList(response: HttpResponseBase): Observable<Report[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Report.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<Report[]>(<any>null);
    }

    /**
     * @return Success
     */
    generateTechMatReport(): Observable<void> {
        let url_ = this.baseUrl + "/api/Bataillon/reports/material";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processGenerateTechMatReport(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateTechMatReport(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processGenerateTechMatReport(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    downloadReport(reportId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Bataillon/reports/material/{reportId}";
        if (reportId === undefined || reportId === null)
            throw new Error("The parameter 'reportId' must be defined.");
        url_ = url_.replace("{reportId}", encodeURIComponent("" + reportId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processDownloadReport(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadReport(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDownloadReport(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    deleteReportById(reportId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Bataillon/reports/material/{reportId}";
        if (reportId === undefined || reportId === null)
            throw new Error("The parameter 'reportId' must be defined.");
        url_ = url_.replace("{reportId}", encodeURIComponent("" + reportId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processDeleteReportById(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteReportById(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteReportById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * Lists all companies
     * @return Success
     */
    getCompanies(): Observable<Company[]> {
        let url_ = this.baseUrl + "/api/Companies";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetCompanies(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompanies(<any>response_);
                } catch (e) {
                    return <Observable<Company[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Company[]>><any>Observable.throw(response_);
        });
    }

    protected processGetCompanies(response: HttpResponseBase): Observable<Company[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Company.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<Company[]>(<any>null);
    }

    /**
     * Updates a company and if there are removed locations their stock + damaged material gets added to the default
    location.
     * @param updated (optional) 
     * @return Success
     */
    updateCompany(updated: Company | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Companies";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updated);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdateCompany(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCompany(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateCompany(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * Create a new company
     * @param company (optional) 
     * @return Success
     */
    newCompany(company: Company | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Companies";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(company);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processNewCompany(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNewCompany(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processNewCompany(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 201) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * Returns a company by id
     * @return Success
     */
    getCompanyById(id: string): Observable<Company> {
        let url_ = this.baseUrl + "/api/Companies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetCompanyById(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompanyById(<any>response_);
                } catch (e) {
                    return <Observable<Company>><any>Observable.throw(e);
                }
            } else
                return <Observable<Company>><any>Observable.throw(response_);
        });
    }

    protected processGetCompanyById(response: HttpResponseBase): Observable<Company> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Company.fromJS(resultData200) : new Company();
            return Observable.of(result200);
            });
        } else if (status === 404) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<Company>(<any>null);
    }

    /**
     * Delete company by id
     * @return Success
     */
    deleteCompanyById(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Companies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processDeleteCompanyById(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCompanyById(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteCompanyById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * Generate a grade and material,servants distribution list template for the given company
    1) If the company has only the default location it generates only KP Rw (initial report).
    2) If there are additional locations it generates a distribution excel =&gt; to distribute all material,servants to
    the
    locations.
     * @return Success
     */
    downloadCompanyTemplate(companyName: string): Observable<FileContentResult> {
        let url_ = this.baseUrl + "/api/Companies/{companyName}/templates";
        if (companyName === undefined || companyName === null)
            throw new Error("The parameter 'companyName' must be defined.");
        url_ = url_.replace("{companyName}", encodeURIComponent("" + companyName)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processDownloadCompanyTemplate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadCompanyTemplate(<any>response_);
                } catch (e) {
                    return <Observable<FileContentResult>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileContentResult>><any>Observable.throw(response_);
        });
    }

    protected processDownloadCompanyTemplate(response: HttpResponseBase): Observable<FileContentResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileContentResult.fromJS(resultData200) : new FileContentResult();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FileContentResult>(<any>null);
    }

    /**
     * Initialize the inventory per company and distribute the company's stock to it's locations (typically at the begging
    of a "WK" or after a "Micro Dispo")
     * @param initialReportPerCompany (optional) filled template file (empty cells = 0)
     * @return Success
     */
    apiCompaniesByCompanyNameReportPost(companyName: string, initialReportPerCompany: any | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Companies/{companyName}/report?";
        if (companyName === undefined || companyName === null)
            throw new Error("The parameter 'companyName' must be defined.");
        url_ = url_.replace("{companyName}", encodeURIComponent("" + companyName)); 
        if (initialReportPerCompany !== undefined)
            url_ += "initialReportPerCompany=" + encodeURIComponent("" + initialReportPerCompany) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processApiCompaniesByCompanyNameReportPost(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApiCompaniesByCompanyNameReportPost(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processApiCompaniesByCompanyNameReportPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * Get the inventory for one company
     * @return Success
     */
    getMaterialInventory(company: string): Observable<MaterialInventoryItem[]> {
        let url_ = this.baseUrl + "/api/Inventory/{company}";
        if (company === undefined || company === null)
            throw new Error("The parameter 'company' must be defined.");
        url_ = url_.replace("{company}", encodeURIComponent("" + company)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetMaterialInventory(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialInventory(<any>response_);
                } catch (e) {
                    return <Observable<MaterialInventoryItem[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<MaterialInventoryItem[]>><any>Observable.throw(response_);
        });
    }

    protected processGetMaterialInventory(response: HttpResponseBase): Observable<MaterialInventoryItem[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(MaterialInventoryItem.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<MaterialInventoryItem[]>(<any>null);
    }

    /**
     * Get the inventory for all companies
     * @return Success
     */
    getMaterialInventoryForAll(): Observable<MaterialInventoryItem[]> {
        let url_ = this.baseUrl + "/api/Inventory";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetMaterialInventoryForAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialInventoryForAll(<any>response_);
                } catch (e) {
                    return <Observable<MaterialInventoryItem[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<MaterialInventoryItem[]>><any>Observable.throw(response_);
        });
    }

    protected processGetMaterialInventoryForAll(response: HttpResponseBase): Observable<MaterialInventoryItem[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(MaterialInventoryItem.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<MaterialInventoryItem[]>(<any>null);
    }

    /**
     * @return Success
     */
    getMaterialInventoryForLocation(company: string, location: string, sapNr: string): Observable<MaterialAllocation> {
        let url_ = this.baseUrl + "/api/Inventory/{company}/material/{sapNr}/locations/{location}";
        if (company === undefined || company === null)
            throw new Error("The parameter 'company' must be defined.");
        url_ = url_.replace("{company}", encodeURIComponent("" + company)); 
        if (location === undefined || location === null)
            throw new Error("The parameter 'location' must be defined.");
        url_ = url_.replace("{location}", encodeURIComponent("" + location)); 
        if (sapNr === undefined || sapNr === null)
            throw new Error("The parameter 'sapNr' must be defined.");
        url_ = url_.replace("{sapNr}", encodeURIComponent("" + sapNr)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetMaterialInventoryForLocation(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialInventoryForLocation(<any>response_);
                } catch (e) {
                    return <Observable<MaterialAllocation>><any>Observable.throw(e);
                }
            } else
                return <Observable<MaterialAllocation>><any>Observable.throw(response_);
        });
    }

    protected processGetMaterialInventoryForLocation(response: HttpResponseBase): Observable<MaterialAllocation> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MaterialAllocation.fromJS(resultData200) : new MaterialAllocation();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<MaterialAllocation>(<any>null);
    }

    /**
     * (currently not in use)  Distribute the company stock to it's locations (typically done after a "Micro Dispo".
     * @param distributionList (optional) 
     * @return Success
     */
    distributeMaterialForCompany(companyName: string, sapNr: string, distributionList: MaterialDistribution | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Inventory/{companyName}/material/{sapNr}/distribution";
        if (companyName === undefined || companyName === null)
            throw new Error("The parameter 'companyName' must be defined.");
        url_ = url_.replace("{companyName}", encodeURIComponent("" + companyName)); 
        if (sapNr === undefined || sapNr === null)
            throw new Error("The parameter 'sapNr' must be defined.");
        url_ = url_.replace("{sapNr}", encodeURIComponent("" + sapNr)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(distributionList);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processDistributeMaterialForCompany(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDistributeMaterialForCompany(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDistributeMaterialForCompany(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * Report that a certain material got damaged (typically only used during exercises)
     * @param patch (optional) 
     * @return Success
     */
    materialDefect(company: string, location: string, sapNr: string, patch: PatchAmount | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Inventory/{company}/locations/{location}/material/{sapNr}/defected";
        if (company === undefined || company === null)
            throw new Error("The parameter 'company' must be defined.");
        url_ = url_.replace("{company}", encodeURIComponent("" + company)); 
        if (location === undefined || location === null)
            throw new Error("The parameter 'location' must be defined.");
        url_ = url_.replace("{location}", encodeURIComponent("" + location)); 
        if (sapNr === undefined || sapNr === null)
            throw new Error("The parameter 'sapNr' must be defined.");
        url_ = url_.replace("{sapNr}", encodeURIComponent("" + sapNr)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(patch);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("patch", url_, options_).flatMap((response_ : any) => {
            return this.processMaterialDefect(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMaterialDefect(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processMaterialDefect(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * Report a damaged material got repaired (typically only used during exercises)
     * @param patch (optional) 
     * @return Success
     */
    materialRepaired(company: string, location: string, sapNr: string, patch: PatchAmount | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Inventory/{company}/locations/{location}/material/{sapNr}/repaired";
        if (company === undefined || company === null)
            throw new Error("The parameter 'company' must be defined.");
        url_ = url_.replace("{company}", encodeURIComponent("" + company)); 
        if (location === undefined || location === null)
            throw new Error("The parameter 'location' must be defined.");
        url_ = url_.replace("{location}", encodeURIComponent("" + location)); 
        if (sapNr === undefined || sapNr === null)
            throw new Error("The parameter 'sapNr' must be defined.");
        url_ = url_.replace("{sapNr}", encodeURIComponent("" + sapNr)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(patch);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("patch", url_, options_).flatMap((response_ : any) => {
            return this.processMaterialRepaired(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMaterialRepaired(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processMaterialRepaired(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * You can change (+/-) the material in use on a location.
     * @param company Company identifier
     * @param sapNr Material used
     * @param location Location of the company
     * @param patch (optional) Change
     * @return Success
     */
    materialUsed(company: string, sapNr: string, location: string, patch: PatchAmount | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Inventory/{company}/locations/{location}/material/{sapNr}/used";
        if (company === undefined || company === null)
            throw new Error("The parameter 'company' must be defined.");
        url_ = url_.replace("{company}", encodeURIComponent("" + company)); 
        if (sapNr === undefined || sapNr === null)
            throw new Error("The parameter 'sapNr' must be defined.");
        url_ = url_.replace("{sapNr}", encodeURIComponent("" + sapNr)); 
        if (location === undefined || location === null)
            throw new Error("The parameter 'location' must be defined.");
        url_ = url_.replace("{location}", encodeURIComponent("" + location)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(patch);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("patch", url_, options_).flatMap((response_ : any) => {
            return this.processMaterialUsed(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMaterialUsed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processMaterialUsed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * Corrects the stock.
     * @param newStock (optional) 
     * @return Success
     */
    correctMaterialStock(company: string, sapNr: string, location: string, newStock: PatchAmount | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Inventory/{company}/locations/{location}/material/{sapNr}/stock";
        if (company === undefined || company === null)
            throw new Error("The parameter 'company' must be defined.");
        url_ = url_.replace("{company}", encodeURIComponent("" + company)); 
        if (sapNr === undefined || sapNr === null)
            throw new Error("The parameter 'sapNr' must be defined.");
        url_ = url_.replace("{sapNr}", encodeURIComponent("" + sapNr)); 
        if (location === undefined || location === null)
            throw new Error("The parameter 'location' must be defined.");
        url_ = url_.replace("{location}", encodeURIComponent("" + location)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newStock);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("patch", url_, options_).flatMap((response_ : any) => {
            return this.processCorrectMaterialStock(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCorrectMaterialStock(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processCorrectMaterialStock(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * Returns all defined material.
     * @return Success
     */
    getMaterialList(): Observable<Material[]> {
        let url_ = this.baseUrl + "/api/Material";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetMaterialList(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialList(<any>response_);
                } catch (e) {
                    return <Observable<Material[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Material[]>><any>Observable.throw(response_);
        });
    }

    protected processGetMaterialList(response: HttpResponseBase): Observable<Material[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Material.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<Material[]>(<any>null);
    }

    /**
     * Creates a new material
     * @param material (optional) 
     * @return Success
     */
    newMaterial(material: Material | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Material";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(material);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processNewMaterial(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNewMaterial(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processNewMaterial(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 201) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * Returns a material by its number (unique).
     * @return Success
     */
    getMaterialById(id: string): Observable<Material> {
        let url_ = this.baseUrl + "/api/Material/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetMaterialById(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialById(<any>response_);
                } catch (e) {
                    return <Observable<Material>><any>Observable.throw(e);
                }
            } else
                return <Observable<Material>><any>Observable.throw(response_);
        });
    }

    protected processGetMaterialById(response: HttpResponseBase): Observable<Material> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Material.fromJS(resultData200) : new Material();
            return Observable.of(result200);
            });
        } else if (status === 404) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<Material>(<any>null);
    }

    /**
     * Updates an existing material
     * @param material (optional) 
     * @return Success
     */
    updateMaterial(id: string, material: Material | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Material/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(material);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdateMaterial(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMaterial(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateMaterial(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * Delete material by id
     * @return Success
     */
    deleteMaterialById(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Material/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processDeleteMaterialById(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMaterialById(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteMaterialById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * Get the servant inventory for one company
     * @return Success
     */
    getServantInventory(company: string): Observable<ServantInventoryItem[]> {
        let url_ = this.baseUrl + "/api/ServantsInventory/{company}";
        if (company === undefined || company === null)
            throw new Error("The parameter 'company' must be defined.");
        url_ = url_.replace("{company}", encodeURIComponent("" + company)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetServantInventory(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetServantInventory(<any>response_);
                } catch (e) {
                    return <Observable<ServantInventoryItem[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServantInventoryItem[]>><any>Observable.throw(response_);
        });
    }

    protected processGetServantInventory(response: HttpResponseBase): Observable<ServantInventoryItem[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ServantInventoryItem.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServantInventoryItem[]>(<any>null);
    }

    /**
     * Get the servant inventory for all companies
     * @return Success
     */
    getServantInventoryForAll(): Observable<ServantInventoryItem[]> {
        let url_ = this.baseUrl + "/api/ServantsInventory";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetServantInventoryForAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetServantInventoryForAll(<any>response_);
                } catch (e) {
                    return <Observable<ServantInventoryItem[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServantInventoryItem[]>><any>Observable.throw(response_);
        });
    }

    protected processGetServantInventoryForAll(response: HttpResponseBase): Observable<ServantInventoryItem[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ServantInventoryItem.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServantInventoryItem[]>(<any>null);
    }

    /**
     * @return Success
     */
    getServantInventoryForLocation(company: string, location: string, grade: Grade): Observable<ServantAllocation> {
        let url_ = this.baseUrl + "/api/ServantsInventory/{company}/servants/{grade}/locations/{location}";
        if (company === undefined || company === null)
            throw new Error("The parameter 'company' must be defined.");
        url_ = url_.replace("{company}", encodeURIComponent("" + company)); 
        if (location === undefined || location === null)
            throw new Error("The parameter 'location' must be defined.");
        url_ = url_.replace("{location}", encodeURIComponent("" + location)); 
        if (grade === undefined || grade === null)
            throw new Error("The parameter 'grade' must be defined.");
        url_ = url_.replace("{grade}", encodeURIComponent("" + grade)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetServantInventoryForLocation(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetServantInventoryForLocation(<any>response_);
                } catch (e) {
                    return <Observable<ServantAllocation>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServantAllocation>><any>Observable.throw(response_);
        });
    }

    protected processGetServantInventoryForLocation(response: HttpResponseBase): Observable<ServantAllocation> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServantAllocation.fromJS(resultData200) : new ServantAllocation();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ServantAllocation>(<any>null);
    }

    /**
     * (currently not in use)  Distribute the company stock to it's locations (typically done after a "Micro Dispo".
     * @param distributionList (optional) 
     * @return Success
     */
    distributeServantsForCompany(companyName: string, grade: Grade2, distributionList: GradeDistribution | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ServantsInventory/{companyName}/servants/{grade}/distribution";
        if (companyName === undefined || companyName === null)
            throw new Error("The parameter 'companyName' must be defined.");
        url_ = url_.replace("{companyName}", encodeURIComponent("" + companyName)); 
        if (grade === undefined || grade === null)
            throw new Error("The parameter 'grade' must be defined.");
        url_ = url_.replace("{grade}", encodeURIComponent("" + grade)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(distributionList);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processDistributeServantsForCompany(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDistributeServantsForCompany(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDistributeServantsForCompany(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * Report that a certain material got damaged (typically only used during exercises)
     * @param patch (optional) 
     * @return Success
     */
    servantDetached(company: string, location: string, grade: Grade3, patch: PatchAmount | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ServantsInventory/{company}/locations/{location}/servants/{grade}/detached";
        if (company === undefined || company === null)
            throw new Error("The parameter 'company' must be defined.");
        url_ = url_.replace("{company}", encodeURIComponent("" + company)); 
        if (location === undefined || location === null)
            throw new Error("The parameter 'location' must be defined.");
        url_ = url_.replace("{location}", encodeURIComponent("" + location)); 
        if (grade === undefined || grade === null)
            throw new Error("The parameter 'grade' must be defined.");
        url_ = url_.replace("{grade}", encodeURIComponent("" + grade)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(patch);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("patch", url_, options_).flatMap((response_ : any) => {
            return this.processServantDetached(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processServantDetached(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processServantDetached(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * Report a damaged material got repaired (typically only used during exercises)
     * @param patch (optional) 
     * @return Success
     */
    servantReturned(company: string, location: string, grade: Grade4, patch: PatchAmount | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ServantsInventory/{company}/locations/{location}/servants/{grade}/returned";
        if (company === undefined || company === null)
            throw new Error("The parameter 'company' must be defined.");
        url_ = url_.replace("{company}", encodeURIComponent("" + company)); 
        if (location === undefined || location === null)
            throw new Error("The parameter 'location' must be defined.");
        url_ = url_.replace("{location}", encodeURIComponent("" + location)); 
        if (grade === undefined || grade === null)
            throw new Error("The parameter 'grade' must be defined.");
        url_ = url_.replace("{grade}", encodeURIComponent("" + grade)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(patch);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("patch", url_, options_).flatMap((response_ : any) => {
            return this.processServantReturned(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processServantReturned(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processServantReturned(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * You can change (+/-) the material in use on a location.
     * @param company Company identifier
     * @param grade Material used
     * @param location Location of the company
     * @param patch (optional) Change
     * @return Success
     */
    servantUsed(company: string, grade: Grade5, location: string, patch: PatchAmount | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ServantsInventory/{company}/locations/{location}/servants/{grade}/used";
        if (company === undefined || company === null)
            throw new Error("The parameter 'company' must be defined.");
        url_ = url_.replace("{company}", encodeURIComponent("" + company)); 
        if (grade === undefined || grade === null)
            throw new Error("The parameter 'grade' must be defined.");
        url_ = url_.replace("{grade}", encodeURIComponent("" + grade)); 
        if (location === undefined || location === null)
            throw new Error("The parameter 'location' must be defined.");
        url_ = url_.replace("{location}", encodeURIComponent("" + location)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(patch);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("patch", url_, options_).flatMap((response_ : any) => {
            return this.processServantUsed(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processServantUsed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processServantUsed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * Corrects the stock.
     * @param newStock (optional) 
     * @return Success
     */
    correctServantStock(company: string, grade: Grade6, location: string, newStock: PatchAmount | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ServantsInventory/{company}/locations/{location}/servants/{grade}/stock";
        if (company === undefined || company === null)
            throw new Error("The parameter 'company' must be defined.");
        url_ = url_.replace("{company}", encodeURIComponent("" + company)); 
        if (grade === undefined || grade === null)
            throw new Error("The parameter 'grade' must be defined.");
        url_ = url_.replace("{grade}", encodeURIComponent("" + grade)); 
        if (location === undefined || location === null)
            throw new Error("The parameter 'location' must be defined.");
        url_ = url_.replace("{location}", encodeURIComponent("" + location)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newStock);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("patch", url_, options_).flatMap((response_ : any) => {
            return this.processCorrectServantStock(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCorrectServantStock(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processCorrectServantStock(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * Corrects the ideal for company.
     * @param newIdeal (optional) 
     * @return Success
     */
    correctIdealForCompany(company: string, grade: Grade7, newIdeal: PatchAmount | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/ServantsInventory/{company}/servants/{grade}/stock";
        if (company === undefined || company === null)
            throw new Error("The parameter 'company' must be defined.");
        url_ = url_.replace("{company}", encodeURIComponent("" + company)); 
        if (grade === undefined || grade === null)
            throw new Error("The parameter 'grade' must be defined.");
        url_ = url_.replace("{grade}", encodeURIComponent("" + grade)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newIdeal);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("patch", url_, options_).flatMap((response_ : any) => {
            return this.processCorrectIdealForCompany(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCorrectIdealForCompany(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processCorrectIdealForCompany(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status === 400) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }
}

export class Report implements IReport {
    id?: string | undefined;
    reportingDate?: Date | undefined;
    type?: ReportType | undefined;

    constructor(data?: IReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.reportingDate = data["reportingDate"] ? new Date(data["reportingDate"].toString()) : <any>undefined;
            this.type = data["type"];
        }
    }

    static fromJS(data: any): Report {
        data = typeof data === 'object' ? data : {};
        let result = new Report();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["reportingDate"] = this.reportingDate ? this.reportingDate.toISOString() : <any>undefined;
        data["type"] = this.type;
        return data; 
    }
}

export interface IReport {
    id?: string | undefined;
    reportingDate?: Date | undefined;
    type?: ReportType | undefined;
}

export class Company implements ICompany {
    id?: string | undefined;
    name: string;
    locations: Location[];
    defaultLocation: Location;

    constructor(data?: ICompany) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.locations = [];
            this.defaultLocation = new Location();
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            if (data["locations"] && data["locations"].constructor === Array) {
                this.locations = [] as any;
                for (let item of data["locations"])
                    this.locations.push(Location.fromJS(item));
            }
            this.defaultLocation = data["defaultLocation"] ? Location.fromJS(data["defaultLocation"]) : new Location();
        }
    }

    static fromJS(data: any): Company {
        data = typeof data === 'object' ? data : {};
        let result = new Company();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (this.locations && this.locations.constructor === Array) {
            data["locations"] = [];
            for (let item of this.locations)
                data["locations"].push(item.toJSON());
        }
        data["defaultLocation"] = this.defaultLocation ? this.defaultLocation.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICompany {
    id?: string | undefined;
    name: string;
    locations: Location[];
    defaultLocation: Location;
}

export class Location implements ILocation {
    name?: string | undefined;

    constructor(data?: ILocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): Location {
        data = typeof data === 'object' ? data : {};
        let result = new Location();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface ILocation {
    name?: string | undefined;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.title = data["title"];
            this.status = data["status"];
            this.detail = data["detail"];
            this.instance = data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data; 
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
}

export class FileContentResult implements IFileContentResult {
    fileContents?: string | undefined;
    readonly contentType?: string | undefined;
    fileDownloadName?: string | undefined;
    lastModified?: Date | undefined;
    entityTag?: EntityTagHeaderValue | undefined;
    enableRangeProcessing?: boolean | undefined;

    constructor(data?: IFileContentResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileContents = data["fileContents"];
            (<any>this).contentType = data["contentType"];
            this.fileDownloadName = data["fileDownloadName"];
            this.lastModified = data["lastModified"] ? new Date(data["lastModified"].toString()) : <any>undefined;
            this.entityTag = data["entityTag"] ? EntityTagHeaderValue.fromJS(data["entityTag"]) : <any>undefined;
            this.enableRangeProcessing = data["enableRangeProcessing"];
        }
    }

    static fromJS(data: any): FileContentResult {
        data = typeof data === 'object' ? data : {};
        let result = new FileContentResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileContents"] = this.fileContents;
        data["contentType"] = this.contentType;
        data["fileDownloadName"] = this.fileDownloadName;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["entityTag"] = this.entityTag ? this.entityTag.toJSON() : <any>undefined;
        data["enableRangeProcessing"] = this.enableRangeProcessing;
        return data; 
    }
}

export interface IFileContentResult {
    fileContents?: string | undefined;
    contentType?: string | undefined;
    fileDownloadName?: string | undefined;
    lastModified?: Date | undefined;
    entityTag?: EntityTagHeaderValue | undefined;
    enableRangeProcessing?: boolean | undefined;
}

export class EntityTagHeaderValue implements IEntityTagHeaderValue {
    readonly tag?: StringSegment | undefined;
    readonly isWeak?: boolean | undefined;

    constructor(data?: IEntityTagHeaderValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).tag = data["tag"] ? StringSegment.fromJS(data["tag"]) : <any>undefined;
            (<any>this).isWeak = data["isWeak"];
        }
    }

    static fromJS(data: any): EntityTagHeaderValue {
        data = typeof data === 'object' ? data : {};
        let result = new EntityTagHeaderValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tag"] = this.tag ? this.tag.toJSON() : <any>undefined;
        data["isWeak"] = this.isWeak;
        return data; 
    }
}

export interface IEntityTagHeaderValue {
    tag?: StringSegment | undefined;
    isWeak?: boolean | undefined;
}

export class StringSegment implements IStringSegment {
    readonly buffer?: string | undefined;
    readonly offset?: number | undefined;
    readonly length?: number | undefined;
    readonly value?: string | undefined;
    readonly hasValue?: boolean | undefined;

    constructor(data?: IStringSegment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).buffer = data["buffer"];
            (<any>this).offset = data["offset"];
            (<any>this).length = data["length"];
            (<any>this).value = data["value"];
            (<any>this).hasValue = data["hasValue"];
        }
    }

    static fromJS(data: any): StringSegment {
        data = typeof data === 'object' ? data : {};
        let result = new StringSegment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["buffer"] = this.buffer;
        data["offset"] = this.offset;
        data["length"] = this.length;
        data["value"] = this.value;
        data["hasValue"] = this.hasValue;
        return data; 
    }
}

export interface IStringSegment {
    buffer?: string | undefined;
    offset?: number | undefined;
    length?: number | undefined;
    value?: string | undefined;
    hasValue?: boolean | undefined;
}

export class IFormFile implements IIFormFile {
    readonly contentType?: string | undefined;
    readonly contentDisposition?: string | undefined;
    readonly headers?: { [key: string] : string[]; } | undefined;
    readonly length?: number | undefined;
    readonly name?: string | undefined;
    readonly fileName?: string | undefined;

    constructor(data?: IIFormFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).contentType = data["contentType"];
            (<any>this).contentDisposition = data["contentDisposition"];
            if (data["headers"]) {
                (<any>this).headers = {} as any;
                for (let key in data["headers"]) {
                    if (data["headers"].hasOwnProperty(key))
                        (<any>this).headers[key] = data["headers"][key] !== undefined ? data["headers"][key] : [];
                }
            }
            (<any>this).length = data["length"];
            (<any>this).name = data["name"];
            (<any>this).fileName = data["fileName"];
        }
    }

    static fromJS(data: any): IFormFile {
        data = typeof data === 'object' ? data : {};
        let result = new IFormFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contentType"] = this.contentType;
        data["contentDisposition"] = this.contentDisposition;
        if (this.headers) {
            data["headers"] = {};
            for (let key in this.headers) {
                if (this.headers.hasOwnProperty(key))
                    data["headers"][key] = this.headers[key];
            }
        }
        data["length"] = this.length;
        data["name"] = this.name;
        data["fileName"] = this.fileName;
        return data; 
    }
}

export interface IIFormFile {
    contentType?: string | undefined;
    contentDisposition?: string | undefined;
    headers?: { [key: string] : string[]; } | undefined;
    length?: number | undefined;
    name?: string | undefined;
    fileName?: string | undefined;
}

export class MaterialInventoryItem implements IMaterialInventoryItem {
    sapNr?: string | undefined;
    readonly stock?: number | undefined;
    readonly used?: number | undefined;
    readonly damaged?: number | undefined;
    readonly available?: number | undefined;
    company?: string | undefined;
    distribution?: MaterialAllocation[] | undefined;

    constructor(data?: IMaterialInventoryItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sapNr = data["sapNr"];
            (<any>this).stock = data["stock"];
            (<any>this).used = data["used"];
            (<any>this).damaged = data["damaged"];
            (<any>this).available = data["available"];
            this.company = data["company"];
            if (data["distribution"] && data["distribution"].constructor === Array) {
                this.distribution = [] as any;
                for (let item of data["distribution"])
                    this.distribution.push(MaterialAllocation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MaterialInventoryItem {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialInventoryItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sapNr"] = this.sapNr;
        data["stock"] = this.stock;
        data["used"] = this.used;
        data["damaged"] = this.damaged;
        data["available"] = this.available;
        data["company"] = this.company;
        if (this.distribution && this.distribution.constructor === Array) {
            data["distribution"] = [];
            for (let item of this.distribution)
                data["distribution"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IMaterialInventoryItem {
    sapNr?: string | undefined;
    stock?: number | undefined;
    used?: number | undefined;
    damaged?: number | undefined;
    available?: number | undefined;
    company?: string | undefined;
    distribution?: MaterialAllocation[] | undefined;
}

export class MaterialAllocation implements IMaterialAllocation {
    location?: string | undefined;
    stock?: number | undefined;
    used?: number | undefined;
    damaged?: number | undefined;
    readonly available?: number | undefined;

    constructor(data?: IMaterialAllocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.location = data["location"];
            this.stock = data["stock"];
            this.used = data["used"];
            this.damaged = data["damaged"];
            (<any>this).available = data["available"];
        }
    }

    static fromJS(data: any): MaterialAllocation {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialAllocation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["location"] = this.location;
        data["stock"] = this.stock;
        data["used"] = this.used;
        data["damaged"] = this.damaged;
        data["available"] = this.available;
        return data; 
    }
}

export interface IMaterialAllocation {
    location?: string | undefined;
    stock?: number | undefined;
    used?: number | undefined;
    damaged?: number | undefined;
    available?: number | undefined;
}

export class MaterialDistribution implements IMaterialDistribution {
    distribution?: MaterialAllocation[] | undefined;

    constructor(data?: IMaterialDistribution) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["distribution"] && data["distribution"].constructor === Array) {
                this.distribution = [] as any;
                for (let item of data["distribution"])
                    this.distribution.push(MaterialAllocation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MaterialDistribution {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialDistribution();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.distribution && this.distribution.constructor === Array) {
            data["distribution"] = [];
            for (let item of this.distribution)
                data["distribution"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IMaterialDistribution {
    distribution?: MaterialAllocation[] | undefined;
}

export class PatchAmount implements IPatchAmount {
    amount?: number | undefined;

    constructor(data?: IPatchAmount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.amount = data["amount"];
        }
    }

    static fromJS(data: any): PatchAmount {
        data = typeof data === 'object' ? data : {};
        let result = new PatchAmount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        return data; 
    }
}

export interface IPatchAmount {
    amount?: number | undefined;
}

export class Material implements IMaterial {
    id?: string | undefined;
    sapNr?: string | undefined;
    category?: string | undefined;
    shortDescription?: string | undefined;
    description?: string | undefined;

    constructor(data?: IMaterial) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.sapNr = data["sapNr"];
            this.category = data["category"];
            this.shortDescription = data["shortDescription"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any): Material {
        data = typeof data === 'object' ? data : {};
        let result = new Material();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sapNr"] = this.sapNr;
        data["category"] = this.category;
        data["shortDescription"] = this.shortDescription;
        data["description"] = this.description;
        return data; 
    }
}

export interface IMaterial {
    id?: string | undefined;
    sapNr?: string | undefined;
    category?: string | undefined;
    shortDescription?: string | undefined;
    description?: string | undefined;
}

export class ServantInventoryItem implements IServantInventoryItem {
    company?: string | undefined;
    grade?: ServantInventoryItemGrade | undefined;
    ideal?: number | undefined;
    readonly stock?: number | undefined;
    readonly used?: number | undefined;
    readonly detached?: number | undefined;
    readonly available?: number | undefined;
    distribution?: ServantAllocation[] | undefined;

    constructor(data?: IServantInventoryItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.company = data["company"];
            this.grade = data["grade"];
            this.ideal = data["ideal"];
            (<any>this).stock = data["stock"];
            (<any>this).used = data["used"];
            (<any>this).detached = data["detached"];
            (<any>this).available = data["available"];
            if (data["distribution"] && data["distribution"].constructor === Array) {
                this.distribution = [] as any;
                for (let item of data["distribution"])
                    this.distribution.push(ServantAllocation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ServantInventoryItem {
        data = typeof data === 'object' ? data : {};
        let result = new ServantInventoryItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["company"] = this.company;
        data["grade"] = this.grade;
        data["ideal"] = this.ideal;
        data["stock"] = this.stock;
        data["used"] = this.used;
        data["detached"] = this.detached;
        data["available"] = this.available;
        if (this.distribution && this.distribution.constructor === Array) {
            data["distribution"] = [];
            for (let item of this.distribution)
                data["distribution"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IServantInventoryItem {
    company?: string | undefined;
    grade?: ServantInventoryItemGrade | undefined;
    ideal?: number | undefined;
    stock?: number | undefined;
    used?: number | undefined;
    detached?: number | undefined;
    available?: number | undefined;
    distribution?: ServantAllocation[] | undefined;
}

export class ServantAllocation implements IServantAllocation {
    location?: string | undefined;
    stock?: number | undefined;
    used?: number | undefined;
    detached?: number | undefined;
    readonly available?: number | undefined;

    constructor(data?: IServantAllocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.location = data["location"];
            this.stock = data["stock"];
            this.used = data["used"];
            this.detached = data["detached"];
            (<any>this).available = data["available"];
        }
    }

    static fromJS(data: any): ServantAllocation {
        data = typeof data === 'object' ? data : {};
        let result = new ServantAllocation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["location"] = this.location;
        data["stock"] = this.stock;
        data["used"] = this.used;
        data["detached"] = this.detached;
        data["available"] = this.available;
        return data; 
    }
}

export interface IServantAllocation {
    location?: string | undefined;
    stock?: number | undefined;
    used?: number | undefined;
    detached?: number | undefined;
    available?: number | undefined;
}

export class GradeDistribution implements IGradeDistribution {
    distribution?: ServantAllocation[] | undefined;

    constructor(data?: IGradeDistribution) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["distribution"] && data["distribution"].constructor === Array) {
                this.distribution = [] as any;
                for (let item of data["distribution"])
                    this.distribution.push(ServantAllocation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GradeDistribution {
        data = typeof data === 'object' ? data : {};
        let result = new GradeDistribution();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.distribution && this.distribution.constructor === Array) {
            data["distribution"] = [];
            for (let item of this.distribution)
                data["distribution"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGradeDistribution {
    distribution?: ServantAllocation[] | undefined;
}

export enum Grade {
    Offizere = "Offizere", 
    HoehereUnteroffiziere = "HoehereUnteroffiziere", 
    Unteroffiziere = "Unteroffiziere", 
    Mannschaft = "Mannschaft", 
}

export enum Grade2 {
    Offizere = "Offizere", 
    HoehereUnteroffiziere = "HoehereUnteroffiziere", 
    Unteroffiziere = "Unteroffiziere", 
    Mannschaft = "Mannschaft", 
}

export enum Grade3 {
    Offizere = "Offizere", 
    HoehereUnteroffiziere = "HoehereUnteroffiziere", 
    Unteroffiziere = "Unteroffiziere", 
    Mannschaft = "Mannschaft", 
}

export enum Grade4 {
    Offizere = "Offizere", 
    HoehereUnteroffiziere = "HoehereUnteroffiziere", 
    Unteroffiziere = "Unteroffiziere", 
    Mannschaft = "Mannschaft", 
}

/** Material used */
export enum Grade5 {
    Offizere = "Offizere", 
    HoehereUnteroffiziere = "HoehereUnteroffiziere", 
    Unteroffiziere = "Unteroffiziere", 
    Mannschaft = "Mannschaft", 
}

export enum Grade6 {
    Offizere = "Offizere", 
    HoehereUnteroffiziere = "HoehereUnteroffiziere", 
    Unteroffiziere = "Unteroffiziere", 
    Mannschaft = "Mannschaft", 
}

export enum Grade7 {
    Offizere = "Offizere", 
    HoehereUnteroffiziere = "HoehereUnteroffiziere", 
    Unteroffiziere = "Unteroffiziere", 
    Mannschaft = "Mannschaft", 
}

export enum ReportType {
    MaterialLevelCompany = "MaterialLevelCompany", 
    MaterialLevelLocation = "MaterialLevelLocation", 
}

export enum ServantInventoryItemGrade {
    Offizere = "Offizere", 
    HoehereUnteroffiziere = "HoehereUnteroffiziere", 
    Unteroffiziere = "Unteroffiziere", 
    Mannschaft = "Mannschaft", 
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return Observable.throw(result);
    else
        return Observable.throw(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}